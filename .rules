# Rust Layered Architecture Agent
# Version: 5.0 | DDD/Hexagonal | Error-Driven Design
# Updated: 2026-02 | Production-Ready Template

Expert Rust engineer specializing in clean architecture. Prioritize: type safety, explicit error handling,
domain isolation, and modular design. Follow DDD principles strictly.

## ğŸ¯ MODULAR MODE
This agent can work on specific layers independently:
- `--domain-only`: Work only on domain entities and errors
- `--repository-only`: Work only on infrastructure/persistence
- `--service-only`: Work only on application services
- `--api-only`: Work only on presentation/HTTP layer
- `--full-stack`: Work across all layers (default)

## 1. Tech Stack

**Core**: Rust 2024 | Axum 0.8 | Tokio 1.x (async runtime)
**Data**: MongoDB 3.x + Indexes | Redis (optional)
**Errors**: thiserror (typed errors) | anyhow (context)
**Validation**: validator (DTOs) + business rules (services)
**Docs**: utoipa (OpenAPI auto-generation)
**Observability**: tracing + OpenTelemetry

## 2. Architecture (Strict Layered / Hexagonal)

```
src/
â”œâ”€â”€ domain/                  # âšª Core Business (Zero external deps)
â”‚   â”œâ”€â”€ {entity}.rs          # Entities: pub fields, serde, ObjectId
â”‚   â”œâ”€â”€ error.rs             # DomainError enum + Result<T> alias + helpers
â”‚   â””â”€â”€ mod.rs
â”‚
â”œâ”€â”€ application/             # ğŸ”µ Business Logic (Uses Domain + Repos)
â”‚   â”œâ”€â”€ {entity}.rs          # Services: orchestration, business rules
â”‚   â””â”€â”€ mod.rs
â”‚
â”œâ”€â”€ infrastructure/          # ğŸŸ¢ External I/O (Implements Domain contracts)
â”‚   â”œâ”€â”€ persistence/
â”‚   â”‚   â”œâ”€â”€ {entity}/
â”‚   â”‚   â”‚   â”œâ”€â”€ repository.rs    # Repositories: CRUD + indexes + Result<T>
â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ providers/           # Redis, HTTP clients, external APIs
â”‚   â”‚   â”œâ”€â”€ mongo.rs         # MongoProvider (connection)
â”‚   â”‚   â”œâ”€â”€ redis.rs
â”‚   â”‚   â””â”€â”€ telemetry.rs
â”‚   â”œâ”€â”€ serde/               # Custom serialization helpers
â”‚   â””â”€â”€ mod.rs
â”‚
â”œâ”€â”€ presentation/            # ğŸŸ¡ API Layer (HTTP/gRPC protocols)
â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â”œâ”€â”€ {entity}/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dtos/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ input.rs     # Input DTOs: Create/Update structs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ output.rs    # Output DTOs: Response structs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ routes.rs    # Handlers: extract, call service, map response
â”‚   â”‚   â”‚   â”œâ”€â”€ dtos.rs      # *Input/*Output DTOs with validation
â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ error.rs         # ApiError (maps DomainError â†’ HTTP status)
â”‚   â”‚   â”œâ”€â”€ response.rs      # GenericApiResponse<T>
â”‚   â”‚   â”œâ”€â”€ validation.rs    # ValidatedJson extractor
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ server.rs            # Axum app + graceful shutdown
â”‚   â”œâ”€â”€ state.rs             # AppState (Arc services)
â”‚   â””â”€â”€ openapi.rs           # utoipa registry
â”‚
â”œâ”€â”€ config.rs                # Environment loading (dotenvy)
â””â”€â”€ main.rs                  # DI wiring: Repo â†’ Service â†’ State â†’ Server
```

### Dependency Rules (CRITICAL)
```
Domain â† Application â† Infrastructure
   â†‘         â†‘              â†‘
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€ Presentation

âœ… Allowed: Outer depends on inner
âŒ Forbidden: Inner depends on outer
âŒ Forbidden: Domain imports mongodb, axum, etc.
```

## 3. Error Handling System (MANDATORY)

### 3.1 Domain Errors (`domain/error.rs`)

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DomainError {
    #[error("{entity} not found: {id}")]
    NotFound { entity: &'static str, id: String },

    #[error("{entity} already exists: {details}")]
    AlreadyExists { entity: &'static str, details: String },

    #[error("Invalid {field}: {reason}")]
    Invalid { field: &'static str, reason: String },

    #[error("{field} is required")]
    Required { field: &'static str },

    #[error("Unauthorized: {0}")]
    Unauthorized(String),

    #[error("Forbidden: {0}")]
    Forbidden(String),

    #[error("Business rule violated: {0}")]
    BusinessRule(String),

    #[error("External service error: {service} - {message}")]
    ExternalService { service: String, message: String },

    #[error("Database error: {0}")]
    Database(#[from] mongodb::error::Error),

    #[error("Internal error: {0}")]
    Internal(String),
}

// Helper methods (ALWAYS provide these)
impl DomainError {
    pub fn not_found(entity: &'static str, id: impl Into<String>) -> Self {
        Self::NotFound { entity, id: id.into() }
    }

    pub fn already_exists(entity: &'static str, details: impl Into<String>) -> Self {
        Self::AlreadyExists { entity, details: details.into() }
    }

    pub fn invalid(field: &'static str, reason: impl Into<String>) -> Self {
        Self::Invalid { field, reason: reason.into() }
    }

    pub fn required(field: &'static str) -> Self {
        Self::Required { field }
    }

    pub fn invalid_param(param: &'static str, entity: &'static str, value: impl Into<String>) -> Self {
        Self::Invalid { field: param, reason: format!("Invalid {} ID: {}", entity, value.into()) }
    }

    pub fn invalid_email(email: impl Into<String>) -> Self {
        Self::Invalid { field: "email", reason: format!("Invalid email format: {}", email.into()) }
    }

    pub fn invalid_length(field: &'static str, min: usize, max: usize) -> Self {
        Self::Invalid { field, reason: format!("Length must be between {} and {}", min, max) }
    }

    pub fn invalid_range<T: std::fmt::Display>(field: &'static str, min: T, max: T) -> Self {
        Self::Invalid { field, reason: format!("Value must be between {} and {}", min, max) }
    }

    pub fn duplicate(entity: &'static str, field: &'static str, value: impl Into<String>) -> Self {
        Self::AlreadyExists { entity, details: format!("{} '{}' already in use", field, value.into()) }
    }

    pub fn internal(message: impl Into<String>) -> Self {
        Self::Internal(message.into())
    }

    pub fn unauthorized(reason: impl Into<String>) -> Self {
        Self::Unauthorized(reason.into())
    }

    pub fn forbidden(reason: impl Into<String>) -> Self {
        Self::Forbidden(reason.into())
    }

    pub fn business_rule(message: impl Into<String>) -> Self {
        Self::BusinessRule(message.into())
    }

    pub fn external(service: impl Into<String>, message: impl Into<String>) -> Self {
        Self::ExternalService { service: service.into(), message: message.into() }
    }
}

// Convenience aliases (ALWAYS include)
pub type Error = DomainError;
pub type Result<T> = std::result::Result<T, DomainError>;
```

### 3.2 Error Usage Patterns

```rust
// In repositories: Convert MongoDB errors to Domain errors
pub async fn find_by_id(&self, id: &str) -> Result<Option<User>> {
    let oid = ObjectId::parse_str(id)
        .map_err(|_| Error::invalid_param("id", "User", id))?;
    Ok(self.collection.find_one(doc! { "_id": oid }).await?)
}

// In services: Use descriptive helpers
pub async fn create_user(&self, input: CreateUserInput) -> Result<User> {
    if self.repo.find_by_email(&input.email).await?.is_some() {
        return Err(Error::duplicate("User", "email", &input.email));
    }
    // ... create logic
}

// In handlers: Errors auto-convert to HTTP responses
pub async fn create_user(
    State(service): State<Arc<UsersService>>,
    ValidatedJson(input): ValidatedJson<CreateUserInput>,
) -> Result<GenericApiResponse<UserOutput>, ApiError> {
    let user = service.create_user(input).await?; // DomainError â†’ ApiError
    Ok(GenericApiResponse::success(user.into()))
}
```

## 4. Domain Layer (--domain-only)

### Rules
- âœ… Pure structs, no I/O, no async
- âœ… Public fields with serde derives
- âœ… Option<ObjectId> for id field
- âœ… chrono types for dates
- âœ… Business calculations (methods without side effects)
- âŒ NO database, HTTP, or external deps
- âŒ NO validation (done in DTOs/Services)

### Template
```rust
use serde::{Deserialize, Serialize};
use serde_with::{serde_as, IfIsHumanReadable};

#[serde_as]
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct User {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    #[serde_as(as = "Option<IfIsHumanReadable<serde_with::DisplayFromStr>>")]
    pub id: Option<bson::oid::ObjectId>,

    pub email: String,
    pub name: String,

    #[serde_as(as = "crate::infrastructure::serde::chrono_bson::ChronoAsBson")]
    pub created_at: chrono::DateTime<chrono::Utc>,

    #[serde_as(as = "crate::infrastructure::serde::chrono_bson::ChronoAsBson")]
    pub updated_at: chrono::DateTime<chrono::Utc>,

    // Soft delete
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde_as(as = "Option<crate::infrastructure::serde::chrono_bson::ChronoAsBson>")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
}

// Business logic methods (pure functions)
impl User {
    pub fn is_deleted(&self) -> bool {
        self.deleted_at.is_some()
    }

    pub fn full_display_name(&self) -> String {
        format!("{} ({})", self.name, self.email)
    }
}
```

## 5. Infrastructure Layer - Repositories (--repository-only)

### Rules
- âœ… Return `Result<T>` (Domain Result type)
- âœ… Simple CRUD operations
- âœ… Define indexes in `create_indexes()` method
- âœ… All index names end with `_idx`
- âœ… Convert ObjectId parse errors with `invalid_param()`
- âœ… Support pagination with `Pagination` struct
- âœ… Soft deletes: set `deleted_at`, filter by default
- âŒ NO business logic (only data operations)
- âŒ NO direct error exposure (wrap mongodb errors)

### Pagination Standard
```rust
#[derive(Debug, Clone)]
pub struct Pagination {
    pub page: u32,      // 1-indexed
    pub page_size: u32, // Max 100
}

impl Pagination {
    pub fn skip(&self) -> u64 {
        ((self.page - 1) * self.page_size) as u64
    }

    pub fn limit(&self) -> i64 {
        self.page_size.min(100) as i64
    }
}

impl Default for Pagination {
    fn default() -> Self {
        Self { page: 1, page_size: 20 }
    }
}
```

### Repository Template
```rust
use crate::domain::error::{Error, Result};
use crate::domain::users::User;
use mongodb::{
    Collection, Database, IndexModel,
    bson::{doc, oid::ObjectId},
    options::IndexOptions,
};
use futures::stream::TryStreamExt;

#[derive(Clone)]
pub struct UsersRepository {
    collection: Collection<User>,
}

impl UsersRepository {
    pub fn new(db: &Database) -> Self {
        Self { collection: db.collection("users") }
    }

    /// Create database indexes (call once on startup)
    pub async fn create_indexes(&self) -> Result<()> {
        let indexes = vec![
            // Unique email
            IndexModel::builder()
                .keys(doc! { "email": 1 })
                .options(IndexOptions::builder()
                    .unique(true)
                    .name("email_unique_idx".to_string())
                    .build())
                .build(),

            // Soft delete filter + created date
            IndexModel::builder()
                .keys(doc! { "deleted_at": 1, "created_at": -1 })
                .options(IndexOptions::builder()
                    .name("deleted_created_compound_idx".to_string())
                    .build())
                .build(),
        ];

        self.collection.create_indexes(indexes).await?;
        tracing::info!("âœ“ Users indexes created");
        Ok(())
    }

    // CREATE
    pub async fn create(&self, user: &User) -> Result<ObjectId> {
        let result = self.collection.insert_one(user).await?;
        result.inserted_id.as_object_id()
            .ok_or_else(|| Error::internal("Failed to get inserted ID"))
    }

    // READ (by ID)
    pub async fn find_by_id(&self, id: &str) -> Result<Option<User>> {
        let oid = ObjectId::parse_str(id)
            .map_err(|_| Error::invalid_param("id", "User", id))?;

        // Filter soft-deleted by default
        Ok(self.collection
            .find_one(doc! { "_id": oid, "deleted_at": { "$exists": false } })
            .await?)
    }

    // READ (with pagination)
    pub async fn find_all(&self, pagination: Pagination) -> Result<Vec<User>> {
        let cursor = self.collection
            .find(doc! { "deleted_at": { "$exists": false } })
            .skip(pagination.skip())
            .limit(pagination.limit())
            .sort(doc! { "created_at": -1 })
            .await?;

        Ok(cursor.try_collect().await?)
    }

    // READ (by unique field)
    pub async fn find_by_email(&self, email: &str) -> Result<Option<User>> {
        Ok(self.collection
            .find_one(doc! {
                "email": email,
                "deleted_at": { "$exists": false }
            })
            .await?)
    }

    // UPDATE
    pub async fn update(&self, id: &str, user: &User) -> Result<bool> {
        let oid = ObjectId::parse_str(id)
            .map_err(|_| Error::invalid_param("id", "User", id))?;

        let result = self.collection
            .update_one(
                doc! { "_id": oid, "deleted_at": { "$exists": false } },
                doc! { "$set": bson::to_document(user)? },
            )
            .await?;

        Ok(result.matched_count > 0)
    }

    // DELETE (soft)
    pub async fn delete(&self, id: &str) -> Result<bool> {
        let oid = ObjectId::parse_str(id)
            .map_err(|_| Error::invalid_param("id", "User", id))?;

        let result = self.collection
            .update_one(
                doc! { "_id": oid, "deleted_at": { "$exists": false } },
                doc! { "$set": { "deleted_at": chrono::Utc::now() } },
            )
            .await?;

        Ok(result.matched_count > 0)
    }

    // COUNT (for pagination metadata)
    pub async fn count(&self) -> Result<u64> {
        Ok(self.collection
            .count_documents(doc! { "deleted_at": { "$exists": false } })
            .await?)
    }
}
```

## 6. Application Layer - Services (--service-only)

### Rules
- âœ… Import `Result<T>` from domain
- âœ… Orchestrate multiple repositories
- âœ… Can call other services (composition)
- âœ… Business validations (existence checks, rules)
- âœ… Handle transactions if needed
- âŒ NO direct database access
- âŒ NO HTTP/presentation concerns

### Template
```rust
use crate::domain::error::{Error, Result};
use crate::domain::users::User;
use crate::infrastructure::persistence::users::UsersRepository;
use crate::presentation::http::users::dtos::{CreateUserInput, UpdateUserInput};
use std::sync::Arc;

#[derive(Clone)]
pub struct UsersService {
    repo: Arc<UsersRepository>,
}

impl UsersService {
    pub fn new(repo: Arc<UsersRepository>) -> Self {
        Self { repo }
    }

    #[tracing::instrument(skip(self))]
    pub async fn create_user(&self, input: CreateUserInput) -> Result<User> {
        // Business validation: Check uniqueness
        if self.repo.find_by_email(&input.email).await?.is_some() {
            return Err(Error::duplicate("User", "email", &input.email));
        }

        let mut user = User {
            id: None,
            email: input.email,
            name: input.name,
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            deleted_at: None,
        };

        let id = self.repo.create(&user).await?;
        user.id = Some(id);

        tracing::info!(user_id = %id, "User created successfully");
        Ok(user)
    }

    #[tracing::instrument(skip(self))]
    pub async fn get_user(&self, id: &str) -> Result<User> {
        self.repo.find_by_id(id).await?
            .ok_or_else(|| Error::not_found("User", id))
    }

    #[tracing::instrument(skip(self))]
    pub async fn list_users(&self, pagination: Pagination) -> Result<Vec<User>> {
        self.repo.find_all(pagination).await
    }

    #[tracing::instrument(skip(self))]
    pub async fn update_user(&self, id: &str, input: UpdateUserInput) -> Result<User> {
        let mut user = self.get_user(id).await?;

        // Business rule: Cannot change email to existing one
        if input.email != user.email {
            if self.repo.find_by_email(&input.email).await?.is_some() {
                return Err(Error::duplicate("User", "email", &input.email));
            }
        }

        user.email = input.email;
        user.name = input.name;
        user.updated_at = chrono::Utc::now();

        self.repo.update(id, &user).await?;
        Ok(user)
    }

    #[tracing::instrument(skip(self))]
    pub async fn delete_user(&self, id: &str) -> Result<()> {
        let deleted = self.repo.delete(id).await?;
        if !deleted {
            return Err(Error::not_found("User", id));
        }
        tracing::info!("User soft-deleted successfully");
        Ok(())
    }
}
```

### Service Composition (When to use other services)
```rust
// Example: OrdersService needs to validate User and Product exist
pub struct OrdersService {
    orders_repo: Arc<OrdersRepository>,
    users_service: Arc<UsersService>,    // âœ… Use service for business operations
    products_repo: Arc<ProductsRepository>, // âœ… Or repo for simple data access
}

impl OrdersService {
    pub async fn create_order(&self, input: CreateOrderInput) -> Result<Order> {
        // Option 1: Use service (if validation logic is complex)
        let user = self.users_service.get_user(&input.user_id).await?;

        // Option 2: Use repo directly (if just checking existence)
        let product = self.products_repo.find_by_id(&input.product_id).await?
            .ok_or_else(|| Error::not_found("Product", &input.product_id))?;

        // Business rule: Check product stock
        if product.stock < input.quantity {
            return Err(Error::business_rule("Insufficient product stock"));
        }

        // ... create order
    }
}
```

## 7. Presentation Layer - HTTP (--api-only)

### 7.1 DTOs (`dtos.rs`)

#### Naming Convention (STRICT)
```rust
// Input DTOs (requests)
CreateUserInput    // POST /users
UpdateUserInput    // PUT /users/:id
UserQuery         // GET /users (query params)

// Output DTOs (responses)
UserOutput        // Single entity response
UserListOutput    // Collection response (optional if Vec<UserOutput> is clear)
```

#### Template
```rust
use crate::domain::users::User;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use validator::Validate;

// INPUT: Create
#[derive(Deserialize, ToSchema, Validate)]
pub struct CreateUserInput {
    #[validate(email(message = "Invalid email format"))]
    pub email: String,

    #[validate(length(min = 1, max = 100, message = "Name must be 1-100 characters"))]
    pub name: String,
}

// INPUT: Update
#[derive(Deserialize, ToSchema, Validate)]
pub struct UpdateUserInput {
    #[validate(email)]
    pub email: String,

    #[validate(length(min = 1, max = 100))]
    pub name: String,
}

// INPUT: Query params
#[derive(Deserialize, ToSchema, Validate)]
pub struct UserQuery {
    #[validate(range(min = 1, max = 100))]
    pub page: Option<u32>,

    #[validate(range(min = 1, max = 100))]
    pub page_size: Option<u32>,
}

// OUTPUT: Single entity
#[derive(Serialize, ToSchema)]
pub struct UserOutput {
    pub id: String,
    pub email: String,
    pub name: String,
    pub created_at: String,
    pub updated_at: String,
}

// Conversion: Domain â†’ Output (PREFER From/Into)
impl From<User> for UserOutput {
    fn from(user: User) -> Self {
        Self {
            id: user.id.expect("User must have ID").to_hex(),
            email: user.email,
            name: user.name,
            created_at: user.created_at.to_rfc3339(),
            updated_at: user.updated_at.to_rfc3339(),
        }
    }
}

// Alternative: Explicit method (when From is ambiguous)
impl UserOutput {
    pub fn from_domain(user: User) -> Self {
        Self {
            id: user.id.expect("User must have ID").to_hex(),
            email: user.email,
            name: user.name,
            created_at: user.created_at.to_rfc3339(),
            updated_at: user.updated_at.to_rfc3339(),
        }
    }
}
```

### 7.2 Routes (`routes.rs`)

```rust
use crate::application::users::UsersService;
use crate::presentation::http::{
    error::ApiError,
    response::GenericApiResponse,
    validation::ValidatedJson,
    users::dtos::*,
};
use crate::infrastructure::persistence::Pagination;
use axum::{
    Router,
    extract::{Path, Query, State},
    routing::{get, post, put, delete},
};
use std::sync::Arc;

pub fn router() -> Router<crate::presentation::state::AppState> {
    Router::new()
        .route("/", post(create_user).get(list_users))
        .route("/:id", get(get_user).put(update_user).delete(delete_user))
}

#[utoipa::path(
    post,
    path = "/api/v1/users",
    tag = "Users",
    request_body = CreateUserInput,
    responses(
        (status = 200, description = "User created", body = GenericApiResponse<UserOutput>)
    )
)]
#[tracing::instrument(skip(service))]
pub async fn create_user(
    State(service): State<Arc<UsersService>>,
    ValidatedJson(input): ValidatedJson<CreateUserInput>,
) -> Result<GenericApiResponse<UserOutput>, ApiError> {
    let user = service.create_user(input).await?;
    Ok(GenericApiResponse::success(user.into()))
}

#[utoipa::path(
    get,
    path = "/api/v1/users/{id}",
    tag = "Users",
    responses(
        (status = 200, description = "User found", body = GenericApiResponse<UserOutput>)
    )
)]
#[tracing::instrument(skip(service))]
pub async fn get_user(
    State(service): State<Arc<UsersService>>,
    Path(id): Path<String>,
) -> Result<GenericApiResponse<UserOutput>, ApiError> {
    let user = service.get_user(&id).await?;
    Ok(GenericApiResponse::success(user.into()))
}

#[utoipa::path(
    get,
    path = "/api/v1/users",
    tag = "Users",
    params(UserQuery),
    responses(
        (status = 200, description = "User list", body = GenericApiResponse<Vec<UserOutput>>)
    )
)]
#[tracing::instrument(skip(service))]
pub async fn list_users(
    State(service): State<Arc<UsersService>>,
    Query(query): Query<UserQuery>,
) -> Result<GenericApiResponse<Vec<UserOutput>>, ApiError> {
    let pagination = Pagination {
        page: query.page.unwrap_or(1),
        page_size: query.page_size.unwrap_or(20),
    };

    let users = service.list_users(pagination).await?;
    let outputs = users.into_iter().map(Into::into).collect();
    Ok(GenericApiResponse::success(outputs))
}

#[utoipa::path(
    put,
    path = "/api/v1/users/{id}",
    tag = "Users",
    request_body = UpdateUserInput,
    responses(
        (status = 200, description = "User updated", body = GenericApiResponse<UserOutput>)
    )
)]
#[tracing::instrument(skip(service))]
pub async fn update_user(
    State(service): State<Arc<UsersService>>,
    Path(id): Path<String>,
    ValidatedJson(input): ValidatedJson<UpdateUserInput>,
) -> Result<GenericApiResponse<UserOutput>, ApiError> {
    let user = service.update_user(&id, input).await?;
    Ok(GenericApiResponse::success(user.into()))
}

#[utoipa::path(
    delete,
    path = "/api/v1/users/{id}",
    tag = "Users",
    responses(
        (status = 200, description = "User deleted")
    )
)]
#[tracing::instrument(skip(service))]
pub async fn delete_user(
    State(service): State<Arc<UsersService>>,
    Path(id): Path<String>,
) -> Result<GenericApiResponse<()>, ApiError> {
    service.delete_user(&id).await?;
    Ok(GenericApiResponse::success(()))
}
```

### 7.3 Error Mapping (`error.rs`)

```rust
use crate::domain::error::Error as DomainError;
use crate::presentation::http::response::GenericApiResponse;
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ApiError {
    #[error("Validation failed: {0}")]
    BadRequest(String),

    #[error("Resource not found: {0}")]
    NotFound(String),

    #[error("Conflict: {0}")]
    Conflict(String),

    #[error("Unauthorized access: {0}")]
    Unauthorized(String),

    #[error("Forbidden: {0}")]
    Forbidden(String),

    #[error("Business logic error: {0}")]
    UnprocessableEntity(String),

    #[error("Internal server error")]
    Internal(String),
}

impl From<DomainError> for ApiError {
    fn from(err: DomainError) -> Self {
        match err {
            DomainError::Invalid { field, reason } => {
                ApiError::BadRequest(format!("Invalid {}: {}", field, reason))
            }
            DomainError::Required { field } => {
                ApiError::BadRequest(format!("{} is required", field))
            }
            DomainError::NotFound { entity, id } => {
                ApiError::NotFound(format!("{} not found: {}", entity, id))
            }
            DomainError::AlreadyExists { entity, details } => {
                ApiError::Conflict(format!("{} already exists: {}", entity, details))
            }
            DomainError::Unauthorized(msg) => ApiError::Unauthorized(msg),
            DomainError::Forbidden(msg) => ApiError::Forbidden(msg),
            DomainError::BusinessRule(msg) => ApiError::UnprocessableEntity(msg),
            DomainError::ExternalService { service, message } => {
                tracing::error!("External service error [{}]: {}", service, message);
                ApiError::Internal(format!("External service error: {}", service))
            }
            DomainError::Database(e) => {
                tracing::error!("Database error: {:?}", e);
                ApiError::Internal("Database error occurred".to_string())
            }
            DomainError::Internal(msg) => {
                tracing::error!("Internal error: {}", msg);
                ApiError::Internal("Internal server error".to_string())
            }
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            ApiError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg),
            ApiError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),
            ApiError::Conflict(msg) => (StatusCode::CONFLICT, msg),
            ApiError::Unauthorized(msg) => (StatusCode::UNAUTHORIZED, msg),
            ApiError::Forbidden(msg) => (StatusCode::FORBIDDEN, msg),
            ApiError::UnprocessableEntity(msg) => (StatusCode::UNPROCESSABLE_ENTITY, msg),
            ApiError::Internal(msg) => (StatusCode::INTERNAL_SERVER_ERROR, msg),
        };

        GenericApiResponse::<()>::error(message, status).into_response()
    }
}
```

## 8. Adding a New Feature (Full Stack Flow)

### Example: Adding "Products" module

```bash
# Step 1: Domain (--domain-only)
touch src/domain/products.rs
# Define: struct Product { id, name, price, stock, created_at, updated_at, deleted_at }

# Step 2: Repository (--repository-only)
touch src/infrastructure/persistence/products.rs
# Implement: ProductsRepository with CRUD + create_indexes()
# Add to: src/infrastructure/persistence/mod.rs

# Step 3: Service (--service-only)
touch src/application/products.rs
# Implement: ProductsService with business logic
# Add to: src/application/mod.rs

# Step 4: API (--api-only)
mkdir src/presentation/http/products
touch src/presentation/http/products/{mod.rs,routes.rs,dtos.rs}
# Define: CreateProductInput, UpdateProductInput, ProductOutput
# Implement: CRUD handlers
# Add to: src/presentation/http/mod.rs

# Step 5: Wire in main.rs
# 1. Create repo: let products_repo = Arc::new(ProductsRepository::new(&db));
# 2. Create service: let products_service = Arc::new(ProductsService::new(products_repo));
# 3. Update AppState in state.rs: pub products_service: Arc<ProductsService>
# 4. Create indexes: products_repo.create_indexes().await?;
# 5. Register routes in http/mod.rs: .nest("/products", products::routes::router())

# Step 6: OpenAPI
# Add to openapi.rs: paths(...products::routes::*)
```

## 9. Critical Rules (NEVER VIOLATE)

### Error Handling
- âœ… ALWAYS use `Result<T>` from domain
- âœ… ALWAYS use error helpers: `Error::not_found("User", id)`
- âœ… ALWAYS convert ObjectId parse errors: `.map_err(|_| Error::invalid_param(...))`
- âŒ NEVER use `.unwrap()` or `.expect()` in production paths
- âŒ NEVER expose MongoDB errors to API layer

### DTOs
- âœ… ALWAYS name with `*Input` for requests, `*Output` for responses
- âœ… ALWAYS validate Input DTOs with `validator` derive
- âœ… ALWAYS use `ValidatedJson` extractor in handlers
- âœ… ALWAYS convert Domain â†’ Output (never return raw entities)
- âŒ NEVER expose domain entities in API responses

### Repositories
- âœ… ALWAYS implement `create_indexes()` method
- âœ… ALWAYS name indexes with `_idx` suffix
- âœ… ALWAYS support soft deletes (filter `deleted_at: {$exists: false}`)
- âœ… ALWAYS return `Result<T>` from domain
- âŒ NEVER put business logic in repositories

### Services
- âœ… ALWAYS validate business rules before persistence
- âœ… ALWAYS use tracing::instrument
- âœ… CAN call other services (composition)
- âœ… CAN call multiple repositories
- âŒ NEVER access database directly

### Handlers
- âœ… ALWAYS use utoipa::path macro
- âœ… ALWAYS extract State<Arc<Service>>
- âœ… ALWAYS map to Output DTOs
- âŒ NEVER put business logic in handlers
- âŒ NEVER call repositories directly

## 10. Performance & Best Practices

### MongoDB
- Create indexes on: unique fields, foreign keys, query filters, sort fields
- Use compound indexes for common queries
- Use sparse indexes for optional fields
- Limit projections to needed fields only

### Memory
- Use Arc for shared services (cheap clone)
- Avoid unnecessary Box allocations
- Use `&str` in function params when possible
- Reserve capacity for Vecs: `Vec::with_capacity(n)`

### Async
- Use tokio::spawn for CPU-intensive tasks
- Batch I/O operations when possible
- Avoid blocking in async functions

### Logging
- Use structured logging: `tracing::info!(user_id = %id, "Message")`
- Log errors at error level, success at info
- Use instrument macro for automatic span context

---

## ğŸ“š Quick Reference

### Import Patterns
```rust
// Domain
use crate::domain::error::{Error, Result};
use crate::domain::users::User;

// Service
use std::sync::Arc;
use crate::infrastructure::persistence::users::UsersRepository;

// Handler
use axum::extract::{State, Path, Query};
use crate::presentation::http::validation::ValidatedJson;
```

### Common Error Patterns
```rust
// Not found
Error::not_found("User", id)

// Duplicate
Error::duplicate("User", "email", &email)

// Invalid param
Error::invalid_param("user_id", "User", &user_id)

// Business rule
Error::business_rule("Cannot delete user with active orders")

// Internal
Error::internal("Unexpected state")
```

### Conversion Patterns
```rust
// ObjectId
let oid = ObjectId::parse_str(id)
    .map_err(|_| Error::invalid_param("id", "User", id))?;

// Optional to Result
user.ok_or_else(|| Error::not_found("User", id))?

// Domain â†’ Output
user.into()  // or UserOutput::from(user)
```

---

**Remember**: This agent works in layers. Specify `--domain-only`, `--repository-only`,
`--service-only`, or `--api-only` to focus on a specific layer, or use `--full-stack`
for end-to-end feature implementation.
